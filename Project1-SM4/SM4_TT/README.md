# SM4算法T-Table优化实现实验报告

## 一、实验目的

1. 深入理解SM4分组密码算法的T-Table优化技术原理及实现方法。
2. 基于C++语言实现SM4算法的T-Table优化版本，通过预计算查找表提升算法性能。
3. 验证T-Table优化算法的正确性，通过标准测试案例及文件加密/解密实验验证功能完整性。
4. 对比分析T-Table优化版本与基础版本的性能差异，掌握密码算法优化技术。

## 二、实验环境

- **操作系统**：Windows 11（64位）
- **编程语言**：C++
- **开发工具**：Visual Studio 2022
- **测试工具**：Hex Edit（验证十六进制数据块格式）、性能测试程序

## 三、T-Table优化原理概述

T-Table优化是密码算法中常用的性能优化技术，通过预计算查找表来替代运行时的复杂运算，从而显著提升算法执行效率。

### 3.1 优化原理

在SM4算法中，合成置换\( T \)由非线性变换\( τ \)和线性变换\( L \)复合而成：
\[ T(x) = L(\tau(x)) \]

传统实现中，每次调用\( T \)函数都需要：
1. 将32位输入拆分为4个字节
2. 通过S盒进行字节替换
3. 重组后进行线性变换\( L \)

T-Table优化通过预计算所有可能的输入输出对应关系，将复杂的运算转换为简单的查表操作。

### 3.2 核心参数

- **分组长度**：128比特（4个32比特字）
- **密钥长度**：128比特（4个32比特字）
- **轮数**：32轮
- **T表大小**：8个256×32位查找表（4个用于加密/解密，4个用于密钥扩展）

### 3.3 优化策略

1. **预计算T表**：  
   对于每个字节值\( i \)（0-255），预计算：
   - \( T0[i] = L(S[i] << 24) \)
   - \( T1[i] = L(S[i] << 16) \)
   - \( T2[i] = L(S[i] << 8) \)
   - \( T3[i] = L(S[i]) \)

2. **预计算T'表**：  
   对于密钥扩展，预计算：
   - \( TK0[i] = L'(S[i] << 24) \)
   - \( TK1[i] = L'(S[i] << 16) \)
   - \( TK2[i] = L'(S[i] << 8) \)
   - \( TK3[i] = L'(S[i]) \)

3. **查表优化**：  
   将原来的复合运算：
   ```cpp
   uint32_t T(uint32_t x) {
       return L(tau(x));
   }
   ```
   优化为：
   ```cpp
   uint32_t T_ttable(uint32_t x) {
       return T0[(x >> 24) & 0xFF] ^
              T1[(x >> 16) & 0xFF] ^
              T2[(x >> 8) & 0xFF] ^
              T3[x & 0xFF];
   }
   ```

## 四、代码实现细节

### 4.1 核心数据结构

- **S盒**：依据GB/T32907-2016定义的256字节置换表，存储于`SBOX[256]`数组。
- **系统参数**：`FK[4]`（固定值：`0xA3B1BAC6, 0x56AA3350, 0x677D9197, 0xB27022DC`）。
- **固定参数**：`CK[32]`（32个32比特轮常量）。
- **T表**：8个256×32位预计算查找表，用于加速合成置换运算。

### 4.2 T表初始化实现

```cpp
static uint32_t T0[256], T1[256], T2[256], T3[256];
static uint32_t TK0[256], TK1[256], TK2[256], TK3[256];

static void init_ttables() {
    if (tables_initialized) return;

    for (int i = 0; i < 256; ++i) {
        uint8_t s = SBOX[i];

        //T表加密/解密（T = L∘τ）
        uint32_t s0 = (uint32_t)s << 24;
        uint32_t s1 = (uint32_t)s << 16;
        uint32_t s2 = (uint32_t)s << 8;
        uint32_t s3 = (uint32_t)s;

        uint32_t L_s0 = s0 ^ ROL(s0, 2) ^ ROL(s0, 10) ^ ROL(s0, 18) ^ ROL(s0, 24);
        uint32_t L_s1 = s1 ^ ROL(s1, 2) ^ ROL(s1, 10) ^ ROL(s1, 18) ^ ROL(s1, 24);
        uint32_t L_s2 = s2 ^ ROL(s2, 2) ^ ROL(s2, 10) ^ ROL(s2, 18) ^ ROL(s2, 24);
        uint32_t L_s3 = s3 ^ ROL(s3, 2) ^ ROL(s3, 10) ^ ROL(s3, 18) ^ ROL(s3, 24);

        T0[i] = L_s0;
        T1[i] = L_s1;
        T2[i] = L_s2;
        T3[i] = L_s3;

        //T'表密钥扩展（T' = L'∘τ）
        uint32_t L_sk0 = s0 ^ ROL(s0, 13) ^ ROL(s0, 23);
        uint32_t L_sk1 = s1 ^ ROL(s1, 13) ^ ROL(s1, 23);
        uint32_t L_sk2 = s2 ^ ROL(s2, 13) ^ ROL(s2, 23);
        uint32_t L_sk3 = s3 ^ ROL(s3, 13) ^ ROL(s3, 23);

        TK0[i] = L_sk0;
        TK1[i] = L_sk1;
        TK2[i] = L_sk2;
        TK3[i] = L_sk3;
    }

    tables_initialized = 1;
}
```

### 4.3 优化后的合成置换函数

```cpp
//基于T表的复合变换T
static uint32_t sm4_T_ttable(uint32_t x) {
    return T0[(x >> 24) & 0xFF] ^
           T1[(x >> 16) & 0xFF] ^
           T2[(x >> 8) & 0xFF] ^
           T3[x & 0xFF];
}

//基于T'表的密钥扩展复合变换T'
static uint32_t sm4_T_prime_ttable(uint32_t x) {
    return TK0[(x >> 24) & 0xFF] ^
           TK1[(x >> 16) & 0xFF] ^
           TK2[(x >> 8) & 0xFF] ^
           TK3[x & 0xFF];
}
```

### 4.4 优化后的加密/解密函数

```cpp
void sm4_encrypt(const uint32_t plaintext[4], const uint32_t key[4], uint32_t ciphertext[4]) {
    init_ttables();  //确保T表已初始化
    
    uint32_t rk[32];
    generate_round_keys(key, rk);
    
    uint32_t X[36];
    X[0] = plaintext[0]; X[1] = plaintext[1]; 
    X[2] = plaintext[2]; X[3] = plaintext[3];
    
    for (int i = 0; i < 32; ++i) {
        X[i + 4] = X[i] ^ sm4_T_ttable(X[i + 1] ^ X[i + 2] ^ X[i + 3] ^ rk[i]);
    }
    
    ciphertext[0] = X[35]; ciphertext[1] = X[34];
    ciphertext[2] = X[33]; ciphertext[3] = X[32];
}
```

### 4.5 密钥扩展优化

```cpp
static void generate_round_keys(const uint32_t key[4], uint32_t rk[32]) {
    uint32_t K[36];
    
    //密钥扩展初始化
    K[0] = key[0] ^ FK[0];
    K[1] = key[1] ^ FK[1];
    K[2] = key[2] ^ FK[2];
    K[3] = key[3] ^ FK[3];

    //生成32轮轮密钥（使用T'表优化）
    for (int i = 0; i < 32; ++i) {
        K[i + 4] = K[i] ^ sm4_T_prime_ttable(K[i + 1] ^ K[i + 2] ^ K[i + 3] ^ CK[i]);
        rk[i] = K[i + 4];
    }
}
```

## 五、实验结果与分析

### 5.1 功能正确性验证

使用GB/T32907-2016附录A中的标准测试案例验证：  
- **输入明文**：`0123456789ABCDEFFEDCBA9876543210`（16字节）  
- **输入密钥**：`0123456789ABCDEFFEDCBA9876543210`（16字节）  
- **预期密文**：`681EDF34D206965E86B3E94F536E4246`（16字节）  

实验结果：T-Table优化版本的加密输出与预期密文完全一致，验证了优化算法的正确性。

### 5.2 多轮加密验证

对同一明文使用相同密钥连续加密1,000,000次，结果与标准示例2一致（密文为`595298C7C6FD271F0402F804C33D3F66`），证明T-Table优化不影响算法的数学正确性。

### 5.3 文件加密测试

对1MB文本文件进行加密和解密操作，解密后文件与原文件完全一致（MD5校验值相同），验证了文件处理逻辑的正确性。

### 5.4 性能测试结果

通过性能测试程序验证，T-Table优化版本在不同数据大小下的性能表现：

| 数据大小 | 基础版本用时(ms) | T-Table版本用时(ms) | 性能提升(%) |
|---------|-----------------|-------------------|------------|
| 1KB     | 0.12           | 0.08             | 33.3       |
| 10KB    | 1.15           | 0.78             | 32.2       |
| 100KB   | 11.45          | 7.82             | 31.7       |
| 1MB     | 114.67         | 78.45            | 31.6       |

### 5.5 内存开销分析

T-Table优化版本的内存开销：
- **T表大小**：8 × 256 × 4字节 = 8KB
- **初始化时间**：约0.1ms（一次性开销）
- **内存访问模式**：具有良好的缓存局部性

### 5.6 优化效果分析

1. **计算复杂度降低**：
   - 基础版本：每次T函数调用需要4次S盒查找 + 4次循环左移 + 4次异或
   - T-Table版本：每次T函数调用只需要4次查表 + 3次异或

2. **缓存友好性**：
   - T表数据连续存储，具有良好的空间局部性
   - 查表操作减少了分支预测失败

3. **指令级并行**：
   - 查表操作可以更好地利用现代CPU的乱序执行
   - 减少了数据依赖链

## 六、问题与解决方案

1. **T表初始化时机**：首次调用加密/解密函数时进行初始化，避免程序启动时的延迟。
2. **内存对齐**：确保T表数据按32位边界对齐，提升内存访问效率。
3. **编译器优化**：使用`static`关键字确保T表在编译时优化，避免重复计算。

## 七、实验结论

本实验成功实现了SM4算法的T-Table优化版本，通过预计算查找表显著提升了算法性能。实验结果表明：

1. **正确性**：T-Table优化版本与基础版本在功能上完全等价，通过了所有标准测试案例。
2. **性能提升**：在测试数据上获得了约30%的性能提升，吞吐量从8-9 MB/s提升至11-12 MB/s。
3. **内存开销**：仅增加8KB的静态内存开销，相对于性能提升而言是可接受的。
4. **实用性**：T-Table优化技术适用于需要高性能SM4加密的应用场景。

T-Table优化是密码算法实现中的经典优化技术，通过空间换时间的策略，在保证算法正确性的前提下显著提升了执行效率。

## 八、项目文件结构

```
SM4_TT/
├── SM4_TT/
│   ├── main.cpp           # 主程序入口
│   ├── SM4_Ttable.cpp     # T-Table优化SM4算法实现
│   ├── SM4_Ttable.h       # 头文件声明
│   └── SM4_TT.vcxproj     # Visual Studio项目文件
├── SM4_TT.sln             # 解决方案文件
├── x64/
│   └── Debug/
│       └── SM4_TT.exe     # 编译后的可执行文件
└── README.md              # 实验报告
```

## 九、使用方法

### 编译项目
1. 使用Visual Studio打开`SM4_TT.sln`
2. 选择Release配置和x64平台
3. 编译项目

### 运行程序（进入SM4_TT.exe所在目录）
```bash
# 加密文件
./SM4_TT.exe -e input.txt（路径） key.txt（路径） output.txt（路径）

# 解密文件
./SM4_TT.exe -d output.txt（路径） key.txt（路径） decrypted.txt（路径）
```

## 参考文献

1. GB/T32907-2016，《信息安全技术 SM4分组密码算法》
2. Long Wen, 《Fast Software Implementation of Crypto Primitives: A Survey Of AES & SM4 Implementation》(2025)
3. SM4算法官方文档及测试向量
